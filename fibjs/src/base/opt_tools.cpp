/*
* opt_tools.cpp
*
*  Created on: Oct 15, 2017
*      Author: lion
*/

#include "utils.h"

namespace fibjs {
const char* opt_tools[] = {
   "--prof-process", "var fs = require(\'fs\');\nvar io = require(\'io\');\n\nfunction read_log(f) {\n    var "
        "bs = new io.BufferedStream(fs.openFile(f));\n    bs.EOL = \'\\n\';\n\n    var root = {"
        "\n        deep: 1,\n        level: 0,\n        cnt: 0,\n        js: 0,\n        subs:"
        " {}\n    };\n\n    var samp;\n    while ((samp = bs.readLine()) !== null) {\n        "
        "JSON.parse(samp).forEach(s => {\n            var sl = s.split(\'\\n\');\n            "
        "var js = sl[0].indexOf(\"(native code)\") === -1;\n\n            var level = 1;\n    "
        "        var cur = root;\n            cur.cnt++;\n            if (js)\n             "
        "   cur.js++;\n\n            sl.reverse().forEach(l => {\n                l = l.subs"
        "tr(7);\n                var sub = cur.subs[l];\n                if (sub === undefi"
        "ned)\n                    cur.subs[l] = sub = {\n                        level: 0,"
        "\n                        cnt: 0,\n                        js: 0,\n                "
        "        subs: {}\n                    };\n\n                sub.level = level++;\n\n "
        "               if (level > root.deep)\n                    root.deep = level;\n\n  "
        "              cur = sub;\n                cur.cnt++;\n                if (js)\n    "
        "                cur.js++;\n            });\n        });\n    }\n\n    return root;\n}\n"
        "\nfunction gen_svg(f, root) {\n    var sum = root.cnt;\n    var h = root.deep * 16 "
        "+ 66;\n    var svg_head = `<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PU"
        "BLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"
        "\">\n<svg version=\"1.1\" width=\"1000\" height=\"${h}\" onload=\"init(evt)\" viewBox=\"0 0"
        " 1000 ${h}\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/19"
        "99/xlink\">\n<defs >\n    <linearGradient id=\"background\" y1=\"0\" y2=\"1\" x1=\"0\" x2=\""
        "0\" >\n        <stop stop-color=\"#eeeeee\" offset=\"5%\" />\n        <stop stop-color="
        "\"#eeeeb0\" offset=\"95%\" />\n    </linearGradient>\n</defs>\n<style type=\"text/css\">\n"
        "    .func_g:hover {\n        stroke:black;\n        stroke-width:0.5;\n        curs"
        "or:pointer;\n    }\n</style>\n\n<script type=\"text/ecmascript\">\n<![CDATA[\n    var de"
        "tails, searchbtn, matchedtxt, svg;\n    function init(evt) { \n        details = d"
        "ocument.getElementById(\"details\").firstChild; \n        searchbtn = document.getE"
        "lementById(\"search\");\n        matchedtxt = document.getElementById(\"matched\");\n "
        "       svg = document.getElementsByTagName(\"svg\")[0];\n        searching = 0;\n   "
        "     unzoom();\n    }\n\n    // mouse-over for info\n    function s(node) {		// show"
        "\n        info = g_to_text(node);\n        details.nodeValue = \"Function: \" + info"
        ";\n    }\n    function c() {			// clear\n        details.nodeValue = \' \';\n    }\n\n  "
        "  // ctrl-F for search\n    window.addEventListener(\"keydown\",function (e) {\n    "
        "    if (e.keyCode === 114 || (e.ctrlKey && e.keyCode === 70)) {\n            e.pr"
        "eventDefault();\n            search_prompt();\n        }\n    })\n\n    // functions\n"
        "    function find_child(parent, name, attr) {\n        var children = parent.chil"
        "dNodes;\n        for (var i=0; i<children.length;i++) {\n            if (children["
        "i].tagName == name)\n                return (attr != undefined) ? children[i].att"
        "ributes[attr].value : children[i];\n        }\n        return;\n    }\n    function "
        "orig_save(e, attr, val) {\n        if (e.attributes[\"_orig_\"+attr] != undefined) "
        "return;\n        if (e.attributes[attr] == undefined) return;\n        if (val == "
        "undefined) val = e.attributes[attr].value;\n        e.setAttribute(\"_orig_\"+attr,"
        " val);\n    }\n    function orig_load(e, attr) {\n        if (e.attributes[\"_orig_\""
        "+attr] == undefined) return;\n        e.attributes[attr].value = e.attributes[\"_o"
        "rig_\"+attr].value;\n        e.removeAttribute(\"_orig_\"+attr);\n    }\n    function "
        "g_to_text(e) {\n        var text = find_child(e, \"title\").firstChild.nodeValue;\n "
        "       return (text)\n    }\n    function g_to_func(e) {\n        var func = g_to_t"
        "ext(e);\n        if (func != null)\n            func = func.replace(/ .*/, \"\");\n  "
        "      return (func);\n    }\n    function update_text(e) {\n        var r = find_ch"
        "ild(e, \"rect\");\n        var t = find_child(e, \"text\");\n        var w = parseFloa"
        "t(r.attributes[\"width\"].value) -3;\n        var txt = find_child(e, \"title\").text"
        "Content.replace(/\\\\([^(]*\\\\)$/,\"\");\n        t.attributes[\"x\"].value = parseFloat"
        "(r.attributes[\"x\"].value) +3;\n        \n        // Smaller than this size won\'t f"
        "it anything\n        if (w < 2*12*0.59) {\n            t.textContent = \"\";\n       "
        "     return;\n        }\n        \n        t.textContent = txt;\n        // Fit in f"
        "ull text width\n        if (/^ *$/.test(txt) || t.getSubStringLength(0, txt.lengt"
        "h) < w)\n            return;\n        \n        for (var x=txt.length-2; x>0; x--) "
        "{\n            if (t.getSubStringLength(0, x+2) <= w) { \n                t.textCo"
        "ntent = txt.substring(0,x) + \"..\";\n                return;\n            }\n       "
        " }\n        t.textContent = \"\";\n    }\n\n    // zoom\n    function zoom_reset(e) {\n "
        "       if (e.attributes != undefined) {\n            orig_load(e, \"x\");\n         "
        "   orig_load(e, \"width\");\n        }\n        if (e.childNodes == undefined) retur"
        "n;\n        for(var i=0, c=e.childNodes; i<c.length; i++) {\n            zoom_rese"
        "t(c[i]);\n        }\n    }\n    function zoom_child(e, x, ratio) {\n        if (e.at"
        "tributes != undefined) {\n            if (e.attributes[\"x\"] != undefined) {\n     "
        "           orig_save(e, \"x\");\n                e.attributes[\"x\"].value = (parseFl"
        "oat(e.attributes[\"x\"].value) - x - 10) * ratio + 10;\n                if(e.tagNam"
        "e == \"text\") e.attributes[\"x\"].value = find_child(e.parentNode, \"rect\", \"x\") + 3"
        ";\n            }\n            if (e.attributes[\"width\"] != undefined) {\n          "
        "      orig_save(e, \"width\");\n                e.attributes[\"width\"].value = parse"
        "Float(e.attributes[\"width\"].value) * ratio;\n            }\n        }\n        \n   "
        "     if (e.childNodes == undefined) return;\n        for(var i=0, c=e.childNodes;"
        " i<c.length; i++) {\n            zoom_child(c[i], x-10, ratio);\n        }\n    }\n "
        "   function zoom_parent(e) {\n        if (e.attributes) {\n            if (e.attri"
        "butes[\"x\"] != undefined) {\n                orig_save(e, \"x\");\n                e."
        "attributes[\"x\"].value = 10;\n            }\n            if (e.attributes[\"width\"] "
        "!= undefined) {\n                orig_save(e, \"width\");\n                e.attribu"
        "tes[\"width\"].value = parseInt(svg.width.baseVal.value) - (10*2);\n            }\n "
        "       }\n        if (e.childNodes == undefined) return;\n        for(var i=0, c=e"
        ".childNodes; i<c.length; i++) {\n            zoom_parent(c[i]);\n        }\n    }\n "
        "   function zoom(node) { \n        var attr = find_child(node, \"rect\").attributes"
        ";\n        var width = parseFloat(attr[\"width\"].value);\n        var xmin = parseF"
        "loat(attr[\"x\"].value);\n        var xmax = parseFloat(xmin + width);\n        var "
        "ymin = parseFloat(attr[\"y\"].value);\n        var ratio = (svg.width.baseVal.value"
        " - 2*10) / width;\n        \n        // XXX: Workaround for JavaScript float issue"
        "s (fix me)\n        var fudge = 0.0001;\n        \n        var unzoombtn = document"
        ".getElementById(\"unzoom\");\n        unzoombtn.style[\"opacity\"] = \"1.0\";\n        \n"
        "        var el = document.getElementsByTagName(\"g\");\n        for(var i=0;i<el.le"
        "ngth;i++){\n            var e = el[i];\n            var a = find_child(e, \"rect\")."
        "attributes;\n            var ex = parseFloat(a[\"x\"].value);\n            var ew = "
        "parseFloat(a[\"width\"].value);\n            // Is it an ancestor\n            if (0"
        " == 0) {\n                var upstack = parseFloat(a[\"y\"].value) > ymin;\n        "
        "    } else {\n                var upstack = parseFloat(a[\"y\"].value) < ymin;\n    "
        "        }\n            if (upstack) {\n                // Direct ancestor\n        "
        "        if (ex <= xmin && (ex+ew+fudge) >= xmax) {\n                    e.style[\""
        "opacity\"] = \"0.5\";\n                    zoom_parent(e);\n                    e.onc"
        "lick = function(e){unzoom(); zoom(this);};\n                    update_text(e);\n "
        "               }\n                // not in current path\n                else\n   "
        "                 e.style[\"display\"] = \"none\";\n            }\n            // Child"
        "ren maybe\n            else {\n                // no common path\n                i"
        "f (ex < xmin || ex + fudge >= xmax) {\n                    e.style[\"display\"] = \""
        "none\";\n                }\n                else {\n                    zoom_child(e"
        ", xmin, ratio);\n                    e.onclick = function(e){zoom(this);};\n      "
        "              update_text(e);\n                }\n            }\n        }\n    }\n  "
        "  function unzoom() {\n        var unzoombtn = document.getElementById(\"unzoom\");"
        "\n        unzoombtn.style[\"opacity\"] = \"0.0\";\n        \n        var el = document."
        "getElementsByTagName(\"g\");\n        for(i=0;i<el.length;i++) {\n            el[i]."
        "style[\"display\"] = \"block\";\n            el[i].style[\"opacity\"] = \"1\";\n          "
        "  zoom_reset(el[i]);\n            update_text(el[i]);\n        }\n    }	\n\n    // se"
        "arch\n    function reset_search() {\n        var el = document.getElementsByTagNam"
        "e(\"rect\");\n        for (var i=0; i < el.length; i++) {\n            orig_load(el["
        "i], \"fill\")\n        }\n    }\n    function search_prompt() {\n        if (!searchin"
        "g) {\n            var term = prompt(\"Enter a search term (regexp \" +\n            "
        "    \"allowed, eg: ^ext4_)\", \"\");\n            if (term != null) {\n               "
        " search(term)\n            }\n        } else {\n            reset_search();\n       "
        "     searching = 0;\n            searchbtn.style[\"opacity\"] = \"0.1\";\n            "
        "searchbtn.firstChild.nodeValue = \"Search\"\n            matchedtxt.style[\"opacity\""
        "] = \"0.0\";\n            matchedtxt.firstChild.nodeValue = \"\"\n        }\n    }\n    "
        "function search(term) {\n        var re = new RegExp(term);\n        var el = docu"
        "ment.getElementsByTagName(\"g\");\n        var matches = new Object();\n        var "
        "maxwidth = 0;\n        for (var i = 0; i < el.length; i++) {\n            var e = "
        "el[i];\n            if (e.attributes[\"class\"].value != \"func_g\")\n                "
        "continue;\n            var func = g_to_func(e);\n            var rect = find_child"
        "(e, \"rect\");\n            if (rect == null) {\n                // the rect might b"
        "e wrapped in an anchor\n                // if nameattr href is being used\n       "
        "         if (rect = find_child(e, \"a\")) {\n                    rect = find_child("
        "r, \"rect\");\n                }\n            }\n            if (func == null || rect"
        " == null)\n                continue;\n\n            // Save max width. Only works a"
        "s we have a root frame\n            var w = parseFloat(rect.attributes[\"width\"].v"
        "alue);\n            if (w > maxwidth)\n                maxwidth = w;\n\n            "
        "if (func.match(re)) {\n                // highlight\n                var x = parse"
        "Float(rect.attributes[\"x\"].value);\n                orig_save(rect, \"fill\");\n    "
        "            rect.attributes[\"fill\"].value =\n                    \"rgb(230,0,230)\""
        ";\n\n                // remember matches\n                if (matches[x] == undefin"
        "ed) {\n                    matches[x] = w;\n                } else {\n             "
        "       if (w > matches[x]) {\n                        // overwrite with parent\n  "
        "                      matches[x] = w;\n                    }\n                }\n  "
        "              searching = 1;\n            }\n        }\n        if (!searching)\n   "
        "         return;\n\n        searchbtn.style[\"opacity\"] = \"1.0\";\n        searchbtn."
        "firstChild.nodeValue = \"Reset Search\"\n\n        // calculate percent matched, exc"
        "luding vertical overlap\n        var count = 0;\n        var lastx = -1;\n        v"
        "ar lastw = 0;\n        var keys = Array();\n        for (k in matches) {\n         "
        "   if (matches.hasOwnProperty(k))\n                keys.push(k);\n        }\n      "
        "  // sort the matched frames by their x location\n        // ascending, then widt"
        "h descending\n        keys.sort(function(a, b){\n                return a - b;\n   "
        "         if (a < b || a > b)\n                return a - b;\n            return ma"
        "tches[b] - matches[a];\n        });\n        // Step through frames saving only th"
        "e biggest bottom-up frames\n        // thanks to the sort order. This relies on t"
        "he tree property\n        // where children are always smaller than their parents"
        ".\n        for (var k in keys) {\n            var x = parseFloat(keys[k]);\n       "
        "     var w = matches[keys[k]];\n            if (x >= lastx + lastw) {\n           "
        "     count += w;\n                lastx = x;\n                lastw = w;\n         "
        "   }\n        }\n        // display matched percent\n        matchedtxt.style[\"opac"
        "ity\"] = \"1.0\";\n        pct = 100 * count / maxwidth;\n        if (pct == 100)\n   "
        "         pct = \"100\"\n        else\n            pct = pct.toFixed(1)\n        match"
        "edtxt.firstChild.nodeValue = \"Matched: \" + pct + \"%\";\n    }\n    function searcho"
        "ver(e) {\n        searchbtn.style[\"opacity\"] = \"1.0\";\n    }\n    function searchou"
        "t(e) {\n        if (searching) {\n            searchbtn.style[\"opacity\"] = \"1.0\";\n"
        "        } else {\n            searchbtn.style[\"opacity\"] = \"0.1\";\n        }\n    }"
        "\n]]>\n</script>\n\n<rect x=\"0.0\" y=\"0\" width=\"1000.0\" height=\"${h}.0\" fill=\"url(#ba"
        "ckground)\"  />\n<text text-anchor=\"middle\" x=\"500\" y=\"24\" font-size=\"17\" font-fam"
        "ily=\"Verdana\" fill=\"rgb(0,0,0)\"  >Flame Graph</text>\n<text text-anchor=\"\" x=\"10."
        "00\" y=\"24\" font-size=\"12\" font-family=\"Verdana\" fill=\"rgb(0,0,0)\" id=\"unzoom\" on"
        "click=\"unzoom()\" style=\"opacity:0.0;cursor:pointer\" >Reset Zoom</text>\n<text tex"
        "t-anchor=\"\" x=\"890.00\" y=\"24\" font-size=\"12\" font-family=\"Verdana\" fill=\"rgb(0,0"
        ",0)\" id=\"search\" onmouseover=\"searchover()\" onmouseout=\"searchout()\" onclick=\"se"
        "arch_prompt()\" style=\"opacity:0.1;cursor:pointer\" >Search</text>\n<text text-anch"
        "or=\"\" x=\"1090.00\" y=\"${h*2-3}\" font-size=\"12\" font-family=\"Verdana\" fill=\"rgb(0,"
        "0,0)\" id=\"matched\" > </text>\n<text text-anchor=\"\" x=\"10\" y=\"${h-17}\" font-size=\""
        "12\" font-family=\"Verdana\" fill=\"rgb(0,0,0)\" id=\"details\" > </text>\n`;\n    var sv"
        "g_foot = `</svg>`;\n\n    var f = fs.openFile(f, \"w\");\n    f.write(svg_head);\n\n   "
        " function hot() {\n        var r = Math.floor(Math.random() * 50) + 205;\n        "
        "var g = Math.floor(Math.random() * 230) + 0;\n        var b = Math.floor(Math.ran"
        "dom() * 55) + 0;\n        return `rgb(${r},${g},${b})`;\n    }\n\n    function cold("
        ") {\n        var r = Math.floor(Math.random() * 60) + 80;\n        var g = Math.fl"
        "oor(Math.random() * 60) + 80;\n        var b = Math.floor(Math.random() * 55) + 1"
        "90;\n        return `rgb(${r},${g},${b})`;\n    }\n\n    function gen_node(name, nod"
        "e, pos) {\n        var x = 10 + 981 * pos / sum;\n        var y = h - 49 - node.le"
        "vel * 16;\n\n        var rgb = node.js > 0 ? hot() : cold();\n\n        f.write(`<g "
        "class=\"func_g\" onmouseover=\"s(this)\" onmouseout=\"c()\" onclick=\"zoom(this)\">\n<tit"
        "le>${name} (${node.cnt} samples, ${(100*node.cnt/sum).toFixed(2)}%)</title><rect"
        " x=\"${x.toFixed(2)}\" y=\"${y}\" width=\"${(981*node.cnt/sum).toFixed(2)}\" height=\"1"
        "5.0\" fill=\"${rgb}\" rx=\"2\" ry=\"2\" />\n<text text-anchor=\"\" x=\"${(x+3).toFixed(2)}\""
        " y=\"${y+10.5}\" font-size=\"12\" font-family=\"Verdana\" fill=\"rgb(0,0,0)\"></text>\n</"
        "g>`);\n\n        for (var l in node.subs) {\n            var n = node.subs[l];\n    "
        "        if (n.cnt > 0) {\n                gen_node(l, n, pos);\n                po"
        "s += n.cnt;\n            }\n        }\n    }\n\n    gen_node(\"all\", root, 0);\n\n    f."
        "write(svg_foot);\n}\n\nif (process.argv.length < 4)\n    console.log(\"\\nUsage: fibjs"
        " --prof-process logfile outfile\\n\");\nelse\n    gen_svg(process.argv[3], read_log("
        "process.argv[2]));",
   NULL
};
}