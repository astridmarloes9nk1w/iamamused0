/*
* opt_tools.cpp
*
*  Created on: Oct 15, 2017
*      Author: lion
*/

#include "utils.h"

namespace fibjs {
const char* opt_tools[] = {
    "--cov-process", "var fs = require(\'fs\');\nvar path = require(\'path\');\n\n//========================="
        "==========================\n/*\nSyntax highlighting with language autodetection.\nh"
        "ttps://highlightjs.org/\n*/\n\nvar hljs = {};\n\n(function (factory) {\n    factory(hl"
        "js);\n}(function (hljs) {\n    // Convenience variables for build-in objects\n    v"
        "ar ArrayProto = [],\n        objectKeys = Object.keys;\n\n    // Global internal va"
        "riables used within the highlight.js library.\n    var languages = {},\n        al"
        "iases = {};\n\n    // Regular expressions used throughout the highlight.js library"
        ".\n    var noHighlightRe = /^(no-?highlight|plain|text)$/i,\n        languagePrefi"
        "xRe = /\\blang(?:uage)?-([\\w-]+)\\b/i,\n        fixMarkupRe = /((^(<[^>]+>|\\t|)+|(?"
        ":\\n)))/gm;\n\n    var spanEndTag = \'</span>\';\n\n    // Global options used when wit"
        "hin external APIs. This is modified when\n    // calling the `hljs.configure` fun"
        "ction.\n    var options = {\n        classPrefix: \'hljs-\',\n        tabReplace: nul"
        "l,\n        useBR: false,\n        languages: undefined\n    };\n\n\n    /* Utility fu"
        "nctions */\n\n    function escape(value) {\n        return value.replace(/&/g, \'&am"
        "p;\').replace(/</g, \'&lt;\').replace(/>/g, \'&gt;\');\n    }\n\n    function tag(node) "
        "{\n        return node.nodeName.toLowerCase();\n    }\n\n    function testRe(re, lex"
        "eme) {\n        var match = re && re.exec(lexeme);\n        return match && match."
        "index === 0;\n    }\n\n    function isNotHighlighted(language) {\n        return noH"
        "ighlightRe.test(language);\n    }\n\n    function blockLanguage(block) {\n        va"
        "r i, match, length, _class;\n        var classes = block.className + \' \';\n\n      "
        "  classes += block.parentNode ? block.parentNode.className : \'\';\n\n        // lan"
        "guage-* takes precedence over non-prefixed class names.\n        match = language"
        "PrefixRe.exec(classes);\n        if (match) {\n            return getLanguage(matc"
        "h[1]) ? match[1] : \'no-highlight\';\n        }\n\n        classes = classes.split(/\\"
        "s+/);\n\n        for (i = 0, length = classes.length; i < length; i++) {\n         "
        "   _class = classes[i]\n\n            if (isNotHighlighted(_class) || getLanguage("
        "_class)) {\n                return _class;\n            }\n        }\n    }\n\n    fun"
        "ction inherit(parent) { // inherit(parent, override_obj, override_obj, ...)\n    "
        "    var key;\n        var result = {};\n        var objects = Array.prototype.slic"
        "e.call(arguments, 1);\n\n        for (key in parent)\n            result[key] = par"
        "ent[key];\n        objects.forEach(function (obj) {\n            for (key in obj)\n"
        "                result[key] = obj[key];\n        });\n        return result;\n    }"
        "\n\n    /* Stream merging */\n\n    function nodeStream(node) {\n        var result ="
        " [];\n        (function _nodeStream(node, offset) {\n            for (var child = "
        "node.firstChild; child; child = child.nextSibling) {\n                if (child.n"
        "odeType === 3)\n                    offset += child.nodeValue.length;\n           "
        "     else if (child.nodeType === 1) {\n                    result.push({\n        "
        "                event: \'start\',\n                        offset: offset,\n        "
        "                node: child\n                    });\n                    offset ="
        " _nodeStream(child, offset);\n                    // Prevent void elements from h"
        "aving an end tag that would actually\n                    // double them in the o"
        "utput. There are more void elements in HTML\n                    // but we list o"
        "nly those realistically expected in code display.\n                    if (!tag(c"
        "hild).match(/br|hr|img|input/)) {\n                        result.push({\n        "
        "                    event: \'stop\',\n                            offset: offset,\n "
        "                           node: child\n                        });\n             "
        "       }\n                }\n            }\n            return offset;\n        })(n"
        "ode, 0);\n        return result;\n    }\n\n    function mergeStreams(original, highl"
        "ighted, value) {\n        var processed = 0;\n        var result = \'\';\n        var"
        " nodeStack = [];\n\n        function selectStream() {\n            if (!original.le"
        "ngth || !highlighted.length) {\n                return original.length ? original"
        " : highlighted;\n            }\n            if (original[0].offset !== highlighted"
        "[0].offset) {\n                return (original[0].offset < highlighted[0].offset"
        ") ? original : highlighted;\n            }\n\n            /*\n          To avoid sta"
        "rting the stream just before it should stop the order is\n          ensured that "
        "original always starts first and closes last:\n    \n          if (event1 == \'star"
        "t\' && event2 == \'start\')\n            return original;\n          if (event1 == \'s"
        "tart\' && event2 == \'stop\')\n            return highlighted;\n          if (event1 "
        "== \'stop\' && event2 == \'start\')\n            return original;\n          if (event"
        "1 == \'stop\' && event2 == \'stop\')\n            return highlighted;\n    \n          "
        "... which is collapsed to:\n          */\n            return highlighted[0].event "
        "=== \'start\' ? original : highlighted;\n        }\n\n        function open(node) {\n "
        "           function attr_str(a) {\n                return \' \' + a.nodeName + \'=\"\'"
        " + escape(a.value).replace(\'\"\', \'&quot;\') + \'\"\';\n            }\n            resul"
        "t += \'<\' + tag(node) + ArrayProto.map.call(node.attributes, attr_str).join(\'\') +"
        " \'>\';\n        }\n\n        function close(node) {\n            result += \'</\' + tag"
        "(node) + \'>\';\n        }\n\n        function render(event) {\n            (event.eve"
        "nt === \'start\' ? open : close)(event.node);\n        }\n\n        while (original.l"
        "ength || highlighted.length) {\n            var stream = selectStream();\n        "
        "    result += escape(value.substring(processed, stream[0].offset));\n            "
        "processed = stream[0].offset;\n            if (stream === original) {\n           "
        "     /*\n                On any opening or closing tag of the original markup we "
        "first close\n                the entire highlighted node stack, then render the o"
        "riginal tag along\n                with all the following original tags at the sa"
        "me offset and then\n                reopen all the tags on the highlighted stack."
        "\n                */\n                nodeStack.reverse().forEach(close);\n        "
        "        do {\n                    render(stream.splice(0, 1)[0]);\n               "
        "     stream = selectStream();\n                } while (stream === original && st"
        "ream.length && stream[0].offset === processed);\n                nodeStack.revers"
        "e().forEach(open);\n            } else {\n                if (stream[0].event === "
        "\'start\') {\n                    nodeStack.push(stream[0].node);\n                }"
        " else {\n                    nodeStack.pop();\n                }\n                r"
        "ender(stream.splice(0, 1)[0]);\n            }\n        }\n        return result + e"
        "scape(value.substr(processed));\n    }\n\n    /* Initialization */\n\n    function ex"
        "pand_mode(mode) {\n        if (mode.variants && !mode.cached_variants) {\n        "
        "    mode.cached_variants = mode.variants.map(function (variant) {\n              "
        "  return inherit(mode, {\n                    variants: null\n                }, v"
        "ariant);\n            });\n        }\n        return mode.cached_variants || (mode."
        "endsWithParent && [inherit(mode)]) || [mode];\n    }\n\n    function compileLanguag"
        "e(language) {\n\n        function reStr(re) {\n            return (re && re.source)"
        " || re;\n        }\n\n        function langRe(value, global) {\n            return n"
        "ew RegExp(\n                reStr(value),\n                \'m\' + (language.case_in"
        "sensitive ? \'i\' : \'\') + (global ? \'g\' : \'\')\n            );\n        }\n\n        fu"
        "nction compileMode(mode, parent) {\n            if (mode.compiled)\n              "
        "  return;\n            mode.compiled = true;\n\n            mode.keywords = mode.ke"
        "ywords || mode.beginKeywords;\n            if (mode.keywords) {\n                v"
        "ar compiled_keywords = {};\n\n                var flatten = function (className, s"
        "tr) {\n                    if (language.case_insensitive) {\n                     "
        "   str = str.toLowerCase();\n                    }\n                    str.split("
        "\' \').forEach(function (kw) {\n                        var pair = kw.split(\'|\');\n "
        "                       compiled_keywords[pair[0]] = [className, pair[1] ? Number"
        "(pair[1]) : 1];\n                    });\n                };\n\n                if ("
        "typeof mode.keywords === \'string\') { // string\n                    flatten(\'keyw"
        "ord\', mode.keywords);\n                } else {\n                    objectKeys(mo"
        "de.keywords).forEach(function (className) {\n                        flatten(clas"
        "sName, mode.keywords[className]);\n                    });\n                }\n    "
        "            mode.keywords = compiled_keywords;\n            }\n            mode.le"
        "xemesRe = langRe(mode.lexemes || /\\w+/, true);\n\n            if (parent) {\n      "
        "          if (mode.beginKeywords) {\n                    mode.begin = \'\\\\b(\' + mo"
        "de.beginKeywords.split(\' \').join(\'|\') + \')\\\\b\';\n                }\n              "
        "  if (!mode.begin)\n                    mode.begin = /\\B|\\b/;\n                mod"
        "e.beginRe = langRe(mode.begin);\n                if (!mode.end && !mode.endsWithP"
        "arent)\n                    mode.end = /\\B|\\b/;\n                if (mode.end)\n   "
        "                 mode.endRe = langRe(mode.end);\n                mode.terminator_"
        "end = reStr(mode.end) || \'\';\n                if (mode.endsWithParent && parent.t"
        "erminator_end)\n                    mode.terminator_end += (mode.end ? \'|\' : \'\') "
        "+ parent.terminator_end;\n            }\n            if (mode.illegal)\n           "
        "     mode.illegalRe = langRe(mode.illegal);\n            if (mode.relevance == nu"
        "ll)\n                mode.relevance = 1;\n            if (!mode.contains) {\n      "
        "          mode.contains = [];\n            }\n            mode.contains = Array.pr"
        "ototype.concat.apply([], mode.contains.map(function (c) {\n                return"
        " expand_mode(c === \'self\' ? mode : c)\n            }));\n            mode.contains"
        ".forEach(function (c) {\n                compileMode(c, mode);\n            });\n\n "
        "           if (mode.starts) {\n                compileMode(mode.starts, parent);\n"
        "            }\n\n            var terminators =\n                mode.contains.map(f"
        "unction (c) {\n                    return c.beginKeywords ? \'\\\\.?(\' + c.begin + \'"
        ")\\\\.?\' : c.begin;\n                })\n                .concat([mode.terminator_en"
        "d, mode.illegal])\n                .map(reStr)\n                .filter(Boolean);\n"
        "            mode.terminators = terminators.length ? langRe(terminators.join(\'|\')"
        ", true) : {\n                exec: function ( /*s*/ ) {\n                    retur"
        "n null;\n                }\n            };\n        }\n\n        compileMode(language"
        ");\n    }\n\n    /*\n      Core highlighting function. Accepts a language name, or a"
        "n alias, and a\n      string with the code to highlight. Returns an object with t"
        "he following\n      properties:\n    \n      - relevance (int)\n      - value (an HT"
        "ML string with highlighting markup)\n    \n      */\n    function highlight(name, v"
        "alue, ignore_illegals, continuation) {\n\n        function subMode(lexeme, mode) {"
        "\n            var i, length;\n\n            for (i = 0, length = mode.contains.leng"
        "th; i < length; i++) {\n                if (testRe(mode.contains[i].beginRe, lexe"
        "me)) {\n                    return mode.contains[i];\n                }\n          "
        "  }\n        }\n\n        function endOfMode(mode, lexeme) {\n            if (testRe"
        "(mode.endRe, lexeme)) {\n                while (mode.endsParent && mode.parent) {"
        "\n                    mode = mode.parent;\n                }\n                retur"
        "n mode;\n            }\n            if (mode.endsWithParent) {\n                ret"
        "urn endOfMode(mode.parent, lexeme);\n            }\n        }\n\n        function is"
        "Illegal(lexeme, mode) {\n            return !ignore_illegals && testRe(mode.illeg"
        "alRe, lexeme);\n        }\n\n        function keywordMatch(mode, match) {\n         "
        "   var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0]"
        ";\n            return mode.keywords.hasOwnProperty(match_str) && mode.keywords[ma"
        "tch_str];\n        }\n\n        function buildSpan(classname, insideSpan, leaveOpen"
        ", noPrefix) {\n            var classPrefix = noPrefix ? \'\' : options.classPrefix,"
        "\n                openSpan = \'<span class=\"\' + classPrefix,\n                close"
        "Span = leaveOpen ? \'\' : spanEndTag\n\n            openSpan += classname + \'\">\';\n\n "
        "           return openSpan + insideSpan + closeSpan;\n        }\n\n        function"
        " processKeywords() {\n            var keyword_match, last_index, match, result;\n\n"
        "            if (!top.keywords)\n                return escape(mode_buffer);\n\n    "
        "        result = \'\';\n            last_index = 0;\n            top.lexemesRe.lastI"
        "ndex = 0;\n            match = top.lexemesRe.exec(mode_buffer);\n\n            whil"
        "e (match) {\n                result += escape(mode_buffer.substring(last_index, m"
        "atch.index));\n                keyword_match = keywordMatch(top, match);\n        "
        "        if (keyword_match) {\n                    relevance += keyword_match[1];\n"
        "                    result += buildSpan(keyword_match[0], escape(match[0]));\n   "
        "             } else {\n                    result += escape(match[0]);\n          "
        "      }\n                last_index = top.lexemesRe.lastIndex;\n                ma"
        "tch = top.lexemesRe.exec(mode_buffer);\n            }\n            return result +"
        " escape(mode_buffer.substr(last_index));\n        }\n\n        function processSubL"
        "anguage() {\n            var explicit = typeof top.subLanguage === \'string\';\n    "
        "        if (explicit && !languages[top.subLanguage]) {\n                return es"
        "cape(mode_buffer);\n            }\n\n            var result = explicit ?\n          "
        "      highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguag"
        "e]) :\n                highlightAuto(mode_buffer, top.subLanguage.length ? top.su"
        "bLanguage : undefined);\n\n            // Counting embedded language score towards"
        " the host language may be disabled\n            // with zeroing the containing mo"
        "de relevance. Usecase in point is Markdown that\n            // allows XML everyw"
        "here and makes every XML snippet to have a much larger Markdown\n            // s"
        "core.\n            if (top.relevance > 0) {\n                relevance += result.r"
        "elevance;\n            }\n            if (explicit) {\n                continuation"
        "s[top.subLanguage] = result.top;\n            }\n            return buildSpan(resu"
        "lt.language, result.value, false, true);\n        }\n\n        function processBuff"
        "er() {\n            result += (top.subLanguage != null ? processSubLanguage() : p"
        "rocessKeywords());\n            mode_buffer = \'\';\n        }\n\n        function sta"
        "rtNewMode(mode) {\n            result += mode.className ? buildSpan(mode.classNam"
        "e, \'\', true) : \'\';\n            top = Object.create(mode, {\n                paren"
        "t: {\n                    value: top\n                }\n            });\n        }\n"
        "\n        function processLexeme(buffer, lexeme) {\n\n            mode_buffer += bu"
        "ffer;\n\n            if (lexeme == null) {\n                processBuffer();\n      "
        "          return 0;\n            }\n\n            var new_mode = subMode(lexeme, to"
        "p);\n            if (new_mode) {\n                if (new_mode.skip) {\n           "
        "         mode_buffer += lexeme;\n                } else {\n                    if "
        "(new_mode.excludeBegin) {\n                        mode_buffer += lexeme;\n       "
        "             }\n                    processBuffer();\n                    if (!new"
        "_mode.returnBegin && !new_mode.excludeBegin) {\n                        mode_buff"
        "er = lexeme;\n                    }\n                }\n                startNewMod"
        "e(new_mode, lexeme);\n                return new_mode.returnBegin ? 0 : lexeme.le"
        "ngth;\n            }\n\n            var end_mode = endOfMode(top, lexeme);\n        "
        "    if (end_mode) {\n                var origin = top;\n                if (origin"
        ".skip) {\n                    mode_buffer += lexeme;\n                } else {\n   "
        "                 if (!(origin.returnEnd || origin.excludeEnd)) {\n               "
        "         mode_buffer += lexeme;\n                    }\n                    proces"
        "sBuffer();\n                    if (origin.excludeEnd) {\n                        "
        "mode_buffer = lexeme;\n                    }\n                }\n                do"
        " {\n                    if (top.className) {\n                        result += sp"
        "anEndTag;\n                    }\n                    if (!top.skip) {\n           "
        "             relevance += top.relevance;\n                    }\n                 "
        "   top = top.parent;\n                } while (top !== end_mode.parent);\n        "
        "        if (end_mode.starts) {\n                    startNewMode(end_mode.starts,"
        " \'\');\n                }\n                return origin.returnEnd ? 0 : lexeme.len"
        "gth;\n            }\n\n            if (isIllegal(lexeme, top))\n                thro"
        "w new Error(\'Illegal lexeme \"\' + lexeme + \'\" for mode \"\' + (top.className || \'<u"
        "nnamed>\') + \'\"\');\n\n            /*\n            Parser should not reach this point"
        " as all types of lexemes should be caught\n            earlier, but if it does du"
        "e to some bug make sure it advances at least one\n            character forward t"
        "o prevent infinite looping.\n            */\n            mode_buffer += lexeme;\n  "
        "          return lexeme.length || 1;\n        }\n\n        var language = getLangua"
        "ge(name);\n        if (!language) {\n            throw new Error(\'Unknown language"
        ": \"\' + name + \'\"\');\n        }\n\n        compileLanguage(language);\n        var to"
        "p = continuation || language;\n        var continuations = {}; // keep continuati"
        "ons for sub-languages\n        var result = \'\',\n            current;\n        for "
        "(current = top; current !== language; current = current.parent) {\n            if"
        " (current.className) {\n                result = buildSpan(current.className, \'\',"
        " true) + result;\n            }\n        }\n        var mode_buffer = \'\';\n        v"
        "ar relevance = 0;\n        try {\n            var match, count, index = 0;\n       "
        "     while (true) {\n                top.terminators.lastIndex = index;\n         "
        "       match = top.terminators.exec(value);\n                if (!match)\n        "
        "            break;\n                count = processLexeme(value.substring(index, "
        "match.index), match[0]);\n                index = match.index + count;\n          "
        "  }\n            processLexeme(value.substr(index));\n            for (current = t"
        "op; current.parent; current = current.parent) { // close dangling modes\n        "
        "        if (current.className) {\n                    result += spanEndTag;\n     "
        "           }\n            }\n            return {\n                relevance: relev"
        "ance,\n                value: result,\n                language: name,\n           "
        "     top: top\n            };\n        } catch (e) {\n            if (e.message && "
        "e.message.indexOf(\'Illegal\') !== -1) {\n                return {\n                "
        "    relevance: 0,\n                    value: escape(value)\n                };\n  "
        "          } else {\n                throw e;\n            }\n        }\n    }\n\n    /"
        "*\n      Highlighting with language detection. Accepts a string with the code to\n"
        "      highlight. Returns an object with the following properties:\n    \n      - l"
        "anguage (detected language)\n      - relevance (int)\n      - value (an HTML strin"
        "g with highlighting markup)\n      - second_best (object with the same structure "
        "for second-best heuristically\n        detected language, may be absent)\n    \n   "
        "   */\n    function highlightAuto(text, languageSubset) {\n        languageSubset "
        "= languageSubset || options.languages || objectKeys(languages);\n        var resu"
        "lt = {\n            relevance: 0,\n            value: escape(text)\n        };\n    "
        "    var second_best = result;\n        languageSubset.filter(getLanguage).forEach"
        "(function (name) {\n            var current = highlight(name, text, false);\n     "
        "       current.language = name;\n            if (current.relevance > second_best."
        "relevance) {\n                second_best = current;\n            }\n            if"
        " (current.relevance > result.relevance) {\n                second_best = result;\n"
        "                result = current;\n            }\n        });\n        if (second_b"
        "est.language) {\n            result.second_best = second_best;\n        }\n        "
        "return result;\n    }\n\n    /*\n      Post-processing of the highlighted markup:\n  "
        "  \n      - replace TABs with something more useful\n      - replace real line-bre"
        "aks with \'<br>\' for non-pre containers\n    \n      */\n    function fixMarkup(valu"
        "e) {\n        return !(options.tabReplace || options.useBR) ?\n            value :"
        "\n            value.replace(fixMarkupRe, function (match, p1) {\n                i"
        "f (options.useBR && match === \'\\n\') {\n                    return \'<br>\';\n       "
        "         } else if (options.tabReplace) {\n                    return p1.replace("
        "/\\t/g, options.tabReplace);\n                }\n                return \'\';\n       "
        "     });\n    }\n\n    function buildClassName(prevClassName, currentLang, resultLa"
        "ng) {\n        var language = currentLang ? aliases[currentLang] : resultLang,\n  "
        "          result = [prevClassName.trim()];\n\n        if (!prevClassName.match(/\\b"
        "hljs\\b/)) {\n            result.push(\'hljs\');\n        }\n\n        if (prevClassNam"
        "e.indexOf(language) === -1) {\n            result.push(language);\n        }\n\n    "
        "    return result.join(\' \').trim();\n    }\n\n    /*\n    Applies highlighting to a "
        "DOM node containing code. Accepts a DOM node and\n    two optional parameters for"
        " fixMarkup.\n    */\n    function highlightBlock(block) {\n        var node, origin"
        "alStream, result, resultNode, text;\n        var language = blockLanguage(block);"
        "\n\n        if (isNotHighlighted(language))\n            return;\n\n        if (optio"
        "ns.useBR) {\n            node = document.createElementNS(\'http://www.w3.org/1999/"
        "xhtml\', \'div\');\n            node.innerHTML = block.innerHTML.replace(/\\n/g, \'\')."
        "replace(/<br[ \\/]*>/g, \'\\n\');\n        } else {\n            node = block;\n       "
        " }\n        text = node.textContent;\n        result = language ? highlight(langua"
        "ge, text, true) : highlightAuto(text);\n\n        originalStream = nodeStream(node"
        ");\n        if (originalStream.length) {\n            resultNode = document.create"
        "ElementNS(\'http://www.w3.org/1999/xhtml\', \'div\');\n            resultNode.innerHT"
        "ML = result.value;\n            result.value = mergeStreams(originalStream, nodeS"
        "tream(resultNode), text);\n        }\n        result.value = fixMarkup(result.valu"
        "e);\n\n        block.innerHTML = result.value;\n        block.className = buildClas"
        "sName(block.className, language, result.language);\n        block.result = {\n    "
        "        language: result.language,\n            re: result.relevance\n        };\n "
        "       if (result.second_best) {\n            block.second_best = {\n             "
        "   language: result.second_best.language,\n                re: result.second_best"
        ".relevance\n            };\n        }\n    }\n\n    /*\n    Updates highlight.js globa"
        "l options with values passed in the form of an object.\n    */\n    function confi"
        "gure(user_options) {\n        options = inherit(options, user_options);\n    }\n\n  "
        "  /*\n    Applies highlighting to all <pre><code>..</code></pre> blocks on a page"
        ".\n    */\n    function initHighlighting() {\n        if (initHighlighting.called)\n"
        "            return;\n        initHighlighting.called = true;\n\n        var blocks "
        "= document.querySelectorAll(\'pre code\');\n        ArrayProto.forEach.call(blocks,"
        " highlightBlock);\n    }\n\n    /*\n    Attaches highlighting to the page load event"
        ".\n    */\n    function initHighlightingOnLoad() {\n        addEventListener(\'DOMCo"
        "ntentLoaded\', initHighlighting, false);\n        addEventListener(\'load\', initHig"
        "hlighting, false);\n    }\n\n    function registerLanguage(name, language) {\n      "
        "  var lang = languages[name] = language(hljs);\n        if (lang.aliases) {\n     "
        "       lang.aliases.forEach(function (alias) {\n                aliases[alias] = "
        "name;\n            });\n        }\n    }\n\n    function listLanguages() {\n        re"
        "turn objectKeys(languages);\n    }\n\n    function getLanguage(name) {\n        name"
        " = (name || \'\').toLowerCase();\n        return languages[name] || languages[alias"
        "es[name]];\n    }\n\n    /* Interface definition */\n\n    hljs.highlight = highlight"
        ";\n    hljs.highlightAuto = highlightAuto;\n    hljs.fixMarkup = fixMarkup;\n    hl"
        "js.highlightBlock = highlightBlock;\n    hljs.configure = configure;\n    hljs.ini"
        "tHighlighting = initHighlighting;\n    hljs.initHighlightingOnLoad = initHighligh"
        "tingOnLoad;\n    hljs.registerLanguage = registerLanguage;\n    hljs.listLanguages"
        " = listLanguages;\n    hljs.getLanguage = getLanguage;\n    hljs.inherit = inherit"
        ";\n\n    // Common regexps\n    hljs.IDENT_RE = \'[a-zA-Z]\\\\w*\';\n    hljs.UNDERSCORE"
        "_IDENT_RE = \'[a-zA-Z_]\\\\w*\';\n    hljs.NUMBER_RE = \'\\\\b\\\\d+(\\\\.\\\\d+)?\';\n    hljs."
        "C_NUMBER_RE = \'(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\"
        "d+)?)\'; // 0x..., 0..., decimal, float\n    hljs.BINARY_NUMBER_RE = \'\\\\b(0b[01]+)"
        "\'; // 0b...\n    hljs.RE_STARTERS_RE = \'!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,"
        "|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^"
        "=|\\\\||\\\\|=|\\\\|\\\\||~\';\n\n    // Common modes\n    hljs.BACKSLASH_ESCAPE = {\n       "
        " begin: \'\\\\\\\\[\\\\s\\\\S]\',\n        relevance: 0\n    };\n    hljs.APOS_STRING_MODE = "
        "{\n        className: \'string\',\n        begin: \'\\\'\',\n        end: \'\\\'\',\n        i"
        "llegal: \'\\\\n\',\n        contains: [hljs.BACKSLASH_ESCAPE]\n    };\n    hljs.QUOTE_S"
        "TRING_MODE = {\n        className: \'string\',\n        begin: \'\"\',\n        end: \'\"\'"
        ",\n        illegal: \'\\\\n\',\n        contains: [hljs.BACKSLASH_ESCAPE]\n    };\n    h"
        "ljs.PHRASAL_WORDS_MODE = {\n        begin: /\\b(a|an|the|are|I\'m|isn\'t|don\'t|doesn"
        "\'t|won\'t|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|y"
        "our|they|like|more)\\b/\n    };\n    hljs.COMMENT = function (begin, end, inherits)"
        " {\n        var mode = hljs.inherit({\n                className: \'comment\',\n     "
        "           begin: begin,\n                end: end,\n                contains: []\n"
        "            },\n            inherits || {}\n        );\n        mode.contains.push("
        "hljs.PHRASAL_WORDS_MODE);\n        mode.contains.push({\n            className: \'d"
        "octag\',\n            begin: \'(?:TODO|FIXME|NOTE|BUG|XXX):\',\n            relevance"
        ": 0\n        });\n        return mode;\n    };\n    hljs.C_LINE_COMMENT_MODE = hljs."
        "COMMENT(\'//\', \'$\');\n    hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT(\'/\\\\*\', \'\\\\*/\')"
        ";\n    hljs.HASH_COMMENT_MODE = hljs.COMMENT(\'#\', \'$\');\n    hljs.NUMBER_MODE = {\n"
        "        className: \'number\',\n        begin: hljs.NUMBER_RE,\n        relevance: 0"
        "\n    };\n    hljs.C_NUMBER_MODE = {\n        className: \'number\',\n        begin: h"
        "ljs.C_NUMBER_RE,\n        relevance: 0\n    };\n    hljs.BINARY_NUMBER_MODE = {\n   "
        "     className: \'number\',\n        begin: hljs.BINARY_NUMBER_RE,\n        relevanc"
        "e: 0\n    };\n    hljs.CSS_NUMBER_MODE = {\n        className: \'number\',\n        be"
        "gin: hljs.NUMBER_RE + \'(\' +\n            \'%|em|ex|ch|rem\' +\n            \'|vw|vh|v"
        "min|vmax\' +\n            \'|cm|mm|in|pt|pc|px\' +\n            \'|deg|grad|rad|turn\' "
        "+\n            \'|s|ms\' +\n            \'|Hz|kHz\' +\n            \'|dpi|dpcm|dppx\' +\n "
        "           \')?\',\n        relevance: 0\n    };\n    hljs.REGEXP_MODE = {\n        cl"
        "assName: \'regexp\',\n        begin: /\\//,\n        end: /\\/[gimuy]*/,\n        illeg"
        "al: /\\n/,\n        contains: [\n            hljs.BACKSLASH_ESCAPE,\n            {\n "
        "               begin: /\\[/,\n                end: /\\]/,\n                relevance"
        ": 0,\n                contains: [hljs.BACKSLASH_ESCAPE]\n            }\n        ]\n "
        "   };\n    hljs.TITLE_MODE = {\n        className: \'title\',\n        begin: hljs.ID"
        "ENT_RE,\n        relevance: 0\n    };\n    hljs.UNDERSCORE_TITLE_MODE = {\n        c"
        "lassName: \'title\',\n        begin: hljs.UNDERSCORE_IDENT_RE,\n        relevance: 0"
        "\n    };\n    hljs.METHOD_GUARD = {\n        // excludes method names from keyword "
        "processing\n        begin: \'\\\\.\\\\s*\' + hljs.UNDERSCORE_IDENT_RE,\n        relevanc"
        "e: 0\n    };\n\n    return hljs;\n}));\n\nhljs.registerLanguage(\'javascript\', function"
        " (hljs) {\n    var IDENT_RE = \'[A-Za-z$_][0-9A-Za-z$_]*\';\n    var KEYWORDS = {\n  "
        "      keyword: \'in of if for while finally var new function do return void else "
        "break catch \' +\n            \'instanceof with throw case default try this switch "
        "continue typeof delete \' +\n            \'let yield const export super debugger as"
        " async await static \' +\n            // ECMAScript 6 modules import\n            \'"
        "import from as\',\n        literal: \'true false null undefined NaN Infinity\',\n    "
        "    built_in: \'eval isFinite isNaN parseFloat parseInt decodeURI decodeURICompon"
        "ent \' +\n            \'encodeURI encodeURIComponent escape unescape Object Functio"
        "n Boolean Error \' +\n            \'EvalError InternalError RangeError ReferenceErr"
        "or StopIteration SyntaxError \' +\n            \'TypeError URIError Number Math Dat"
        "e String RegExp Array Float32Array \' +\n            \'Float64Array Int16Array Int3"
        "2Array Int8Array Uint16Array Uint32Array \' +\n            \'Uint8Array Uint8Clampe"
        "dArray ArrayBuffer DataView JSON Intl arguments require \' +\n            \'module "
        "console window document Symbol Set Map WeakSet WeakMap Proxy Reflect \' +\n       "
        "     \'Promise\'\n    };\n    var EXPRESSIONS;\n    var NUMBER = {\n        className:"
        " \'number\',\n        variants: [{\n                begin: \'\\\\b(0[bB][01]+)\'\n       "
        "     },\n            {\n                begin: \'\\\\b(0[oO][0-7]+)\'\n            },\n "
        "           {\n                begin: hljs.C_NUMBER_RE\n            }\n        ],\n  "
        "      relevance: 0\n    };\n    var SUBST = {\n        className: \'subst\',\n        "
        "begin: \'\\\\$\\\\{\',\n        end: \'\\\\}\',\n        keywords: KEYWORDS,\n        contain"
        "s: [] // defined later\n    };\n    var TEMPLATE_STRING = {\n        className: \'st"
        "ring\',\n        begin: \'`\',\n        end: \'`\',\n        contains: [\n            hlj"
        "s.BACKSLASH_ESCAPE,\n            SUBST\n        ]\n    };\n    SUBST.contains = [\n  "
        "      hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        TEMPLATE_ST"
        "RING,\n        NUMBER,\n        hljs.REGEXP_MODE\n    ]\n    var PARAMS_CONTAINS = S"
        "UBST.contains.concat([\n        hljs.C_BLOCK_COMMENT_MODE,\n        hljs.C_LINE_CO"
        "MMENT_MODE\n    ]);\n\n    return {\n        aliases: [\'js\', \'jsx\'],\n        keyword"
        "s: KEYWORDS,\n        contains: [{\n                className: \'meta\',\n           "
        "     relevance: 10,\n                begin: /^\\s*[\'\"]use (strict|asm)[\'\"]/\n      "
        "      },\n            {\n                className: \'meta\',\n                begin:"
        " /^#!/,\n                end: /$/\n            },\n            hljs.APOS_STRING_MOD"
        "E,\n            hljs.QUOTE_STRING_MODE,\n            TEMPLATE_STRING,\n            "
        "hljs.C_LINE_COMMENT_MODE,\n            hljs.C_BLOCK_COMMENT_MODE,\n            NUM"
        "BER,\n            { // object attr container\n                begin: /[{,]\\s*/,\n  "
        "              relevance: 0,\n                contains: [{\n                    beg"
        "in: IDENT_RE + \'\\\\s*:\',\n                    returnBegin: true,\n                 "
        "   relevance: 0,\n                    contains: [{\n                        classN"
        "ame: \'attr\',\n                        begin: IDENT_RE,\n                        re"
        "levance: 0\n                    }]\n                }]\n            },\n            "
        "{ // \"value\" container\n                begin: \'(\' + hljs.RE_STARTERS_RE + \'|\\\\b("
        "case|return|throw)\\\\b)\\\\s*\',\n                keywords: \'return throw case\',\n    "
        "            contains: [\n                    hljs.C_LINE_COMMENT_MODE,\n          "
        "          hljs.C_BLOCK_COMMENT_MODE,\n                    hljs.REGEXP_MODE,\n     "
        "               {\n                        className: \'function\',\n                "
        "        begin: \'(\\\\(.*?\\\\)|\' + IDENT_RE + \')\\\\s*=>\',\n                        ret"
        "urnBegin: true,\n                        end: \'\\\\s*=>\',\n                        c"
        "ontains: [{\n                            className: \'params\',\n                   "
        "         variants: [{\n                                    begin: IDENT_RE\n      "
        "                          },\n                                {\n                 "
        "                   begin: /\\(\\s*\\)/,\n                                },\n        "
        "                        {\n                                    begin: /\\(/,\n     "
        "                               end: /\\)/,\n                                    ex"
        "cludeBegin: true,\n                                    excludeEnd: true,\n        "
        "                            keywords: KEYWORDS,\n                                "
        "    contains: PARAMS_CONTAINS\n                                }\n                "
        "            ]\n                        }]\n                    },\n                "
        "    { // E4X / JSX\n                        begin: /</,\n                        e"
        "nd: /(\\/\\w+|\\w+\\/)>/,\n                        subLanguage: \'xml\',\n              "
        "          contains: [{\n                                begin: /<\\w+\\s*\\/>/,\n    "
        "                            skip: true\n                            },\n          "
        "                  {\n                                begin: /<\\w+/,\n             "
        "                   end: /(\\/\\w+|\\w+\\/)>/,\n                                skip: "
        "true,\n                                contains: [{\n                             "
        "           begin: /<\\w+\\s*\\/>/,\n                                        skip: tr"
        "ue\n                                    },\n                                    \'s"
        "elf\'\n                                ]\n                            }\n           "
        "             ]\n                    }\n                ],\n                relevanc"
        "e: 0\n            },\n            {\n                className: \'function\',\n       "
        "         beginKeywords: \'function\',\n                end: /\\{/,\n                e"
        "xcludeEnd: true,\n                contains: [\n                    hljs.inherit(hl"
        "js.TITLE_MODE, {\n                        begin: IDENT_RE\n                    }),"
        "\n                    {\n                        className: \'params\',\n            "
        "            begin: /\\(/,\n                        end: /\\)/,\n                    "
        "    excludeBegin: true,\n                        excludeEnd: true,\n              "
        "          contains: PARAMS_CONTAINS\n                    }\n                ],\n   "
        "             illegal: /\\[|%/\n            },\n            {\n                begin:"
        " /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` a"
        "nd `$.something`\n            },\n            hljs.METHOD_GUARD,\n            { // "
        "ES6 class\n                className: \'class\',\n                beginKeywords: \'cl"
        "ass\',\n                end: /[{;=]/,\n                excludeEnd: true,\n          "
        "      illegal: /[:\"\\[\\]]/,\n                contains: [{\n                        "
        "beginKeywords: \'extends\'\n                    },\n                    hljs.UNDERSC"
        "ORE_TITLE_MODE\n                ]\n            },\n            {\n                be"
        "ginKeywords: \'constructor\',\n                end: /\\{/,\n                excludeEn"
        "d: true\n            }\n        ],\n        illegal: /#(?!!)/\n    };\n});\n\n//======="
        "============================================\n\nfunction read_lcov(lcov) {\n    var"
        " lines = fs.readLines(lcov);\n    var info = {\n        subs: {}\n    };\n    var cu"
        "r;\n    var re = /^([^:]*):([^,]*)(,(.*))?/;\n    var cnt;\n\n    lines.forEach(l =>"
        " {\n        var m = re.exec(l);\n        if (m) {\n            switch (m[1]) {\n    "
        "            case \'SF\':\n                    var fname = path.fullpath(m[2]);\n    "
        "                var ns = fname.replace(/[\\\\\\/]+/g, \'/\').split(\'/\');\n            "
        "        cur = info;\n                    ns.forEach(n => {\n                      "
        "  var c = cur.subs[n];\n                        if (c === undefined) {\n          "
        "                  c = {\n                                subs: {}\n               "
        "             };\n                            cur.subs[n] = c;\n                   "
        "     }\n                        cur = c;\n                    });\n\n               "
        "     cur.src = fname;\n                    cur.stats = {\n                        "
        "line_cnt: 0,\n                        line_cov: 0,\n                        func_c"
        "nt: 0,\n                        func_cov: 0\n                    };\n              "
        "      cur.lines = [];\n\n                    break;\n                case \'DA\':\n   "
        "                 cnt = Number(m[4]);\n                    cur.lines[Number(m[2]) "
        "- 1] = cnt;\n                    cur.stats.line_cnt++;\n                    if (cn"
        "t > 0)\n                        cur.stats.line_cov++;\n                    break;\n"
        "                case \'FNDA\':\n                    if (m[4] !== \'\') {\n            "
        "            cnt = Number(m[2]);\n                        cur.stats.func_cnt++;\n  "
        "                      if (cnt > 0)\n                            cur.stats.func_co"
        "v++;\n                    }\n                    break;\n                    // def"
        "ault:\n                    //     console.log(m);\n            }\n        }\n    });"
        "\n\n    return info;\n}\n\nfunction gen_one_html(base_path, info) {\n    console.log(p"
        "ath.join(base_path, info.pname), info.name);\n    var htmls = [];\n\n    function g"
        "et_color(rate) {\n        var s;\n        if (rate >= 90)\n            s = \'green\';"
        "\n        else if (rate >= 75)\n            s = \'yellow\';\n        else\n           "
        " s = \'red\';\n        return s;\n    }\n\n    function gen_info(cov, cnt) {\n        v"
        "ar rate = cnt ? (cov / cnt * 100).toFixed(2) : \"100.00\";\n        var s = get_col"
        "or(rate);\n        return `<span>${cov}</span><span>${cnt}</span><span class=\"${s"
        "}\">${rate}%</span>`;\n    }\n\n    function gen_info_td(cov, cnt) {\n        var rat"
        "e = cnt ? (cov / cnt * 100).toFixed(2) : \"100.00\";\n        var s = get_color(rat"
        "e);\n        return `<td class=\"${s}\"><span>${rate}%</span><small>(${cov}/${cnt})"
        "</small></td>`;\n    }\n\n    function gen_bar(cov, cnt) {\n        var rate = cnt ?"
        " (cov / cnt * 100).toFixed(2) : \"100.00\";\n        var s = get_color(rate);\n     "
        "   return `<td><div class=\"box\"><div style=\"width:${rate}px;\" class=\"${s}\"></div"
        "></div></td>`;\n    }\n\n    htmls.push(`\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n"
        "    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width"
        ", initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n"
        "    <style>\n        body,\n        html {\n            margin: 0;\n            padd"
        "ing: 0;\n            font-family: Avenir, \'Segoe UI\', Arial, \'Hiragino Sans GB\', "
        "冬青黑, \'Microsoft YaHei\', 微软雅黑, SimSun, 宋体, Helvetica, Tahoma, \'Arial sans-serif\';"
        "\n        }\n\n        .head {\n            background-color: #eee;\n            posi"
        "tion: fixed;\n            top: 0px;\n            width: 100%;\n            height: "
        "150px;\n            border-bottom: 2px solid #999;\n        }\n\n        h1 {\n      "
        "      text-align: center;\n        }\n\n        .head .navbar {\n            margin:"
        " 10px;\n            float: left;\n        }\n\n        .head .info {\n            pos"
        "ition: absolute;\n            right: 10px;\n        }\n        \n        .head span "
        "{\n            display: inline-block;\n            background-color: #dbe8fd;\n    "
        "        margin: 4px;\n            padding: 4px 15px;\n        }\n\n        .head .ti"
        "tle {\n            font-weight: bold;\n            background-color: transparent;\n"
        "            padding: 4px 4px;\n        }\n\n        .context {\n            margin-t"
        "op: 150px;\n            padding: 10px;\n        }\n\n        .context table {\n      "
        "      width: 100%;\n            border-spacing: 0;\n            border-collapse: c"
        "ollapse;\n        }\n\n        .context td, th {\n            padding: 6px 13px;\n   "
        "         border: 1px solid #fff;\n            white-space: nowrap;\n        }\n\n   "
        "     .context th {\n            background-color: #668ad2;\n            color: #ff"
        "f;\n        }\n\n        .context td {\n            background-color: #dbe8fd;\n     "
        "   }\n\n        .head .green,\n        .context .green {\n            background-col"
        "or: #adfaa1;\n        }\n\n        .head .yellow,\n        .context .yellow {\n      "
        "      background-color: #ffe83e;\n        }\n        \n        .head .red,\n        "
        ".context .red {\n            background-color: #fa141b;\n        }\n\n        .conte"
        "xt pre {\n            border: 1px solid #ccc;\n            border-radius: 4px;\n   "
        "     }\n\n        .context .nocov {\n            background-color: #ffb0b0;\n       "
        " }\n\n        .context .no {\n            display: inline-block;\n            width:"
        " 40px;\n            margin-right: 8px;\n            padding-right: 3px;\n          "
        "  border-right: 1px solid #999;\n            text-align: right;\n        }\n       "
        " \n        .context td span {\n            display: inline-block;\n            widt"
        "h: 80px;\n        }\n\n        .context td div.box {\n            width: 100px;\n    "
        "        border: 1px solid #999;\n        }\n\n        .context td div.box div {\n   "
        "         height: 15px;\n        }\n\n        .context td small {\n            displa"
        "y: inline-block;\n            width: 70px;\n            text-align: right;\n       "
        " }\n\n        /*\n        \n        Colorbrewer theme\n        Original: https://gith"
        "ub.com/mbostock/colorbrewer-theme (c) Mike Bostock <mike@ocks.org>\n        Porte"
        "d by Fabrício Tavares de Oliveira\n        \n        */\n        \n        .hljs {\n "
        "         display: block;\n          overflow-x: auto;\n          padding: 0.5em;\n "
        "         background: #fff;\n        }\n        \n        .hljs,\n        .hljs-subst"
        " {\n          color: #000;\n        }\n        \n        .hljs-string,\n        .hljs"
        "-meta,\n        .hljs-symbol,\n        .hljs-template-tag,\n        .hljs-template-"
        "variable,\n        .hljs-addition {\n          color: #756bb1;\n        }\n        \n"
        "        .hljs-comment,\n        .hljs-quote {\n          color: #636363;\n        }"
        "\n        \n        .hljs-number,\n        .hljs-regexp,\n        .hljs-literal,\n   "
        "     .hljs-bullet,\n        .hljs-link {\n          color: #31a354;\n        }\n    "
        "    \n        .hljs-deletion,\n        .hljs-variable {\n          color: #88f;\n   "
        "     }\n        \n        \n        \n        .hljs-keyword,\n        .hljs-selector-"
        "tag,\n        .hljs-title,\n        .hljs-section,\n        .hljs-built_in,\n       "
        " .hljs-doctag,\n        .hljs-type,\n        .hljs-tag,\n        .hljs-name,\n      "
        "  .hljs-selector-id,\n        .hljs-selector-class,\n        .hljs-strong {\n      "
        "    color: #3182bd;\n        }\n        \n        .hljs-emphasis {\n          font-s"
        "tyle: italic;\n        }\n        \n        .hljs-attribute {\n          color: #e65"
        "50d;\n        }\n        \n      </style>\n    <title>Code coverage report for fibjs"
        "</title>\n</head>`);\n\n    htmls.push(`<body>\n    <div class=\"head\">\n        <h1>C"
        "ode coverage report for fibjs</h1>\n        <div class=\"navbar\">Path: ${info.path"
        "}</div>\n        <div class=\"info\">\n            <span class=\"title\">Lines:</span>"
        "${gen_info(info.stats.line_cov, info.stats.line_cnt)}\n            <span class=\"t"
        "itle\">Functions:</span>${gen_info(info.stats.func_cov, info.stats.func_cnt)}\n   "
        "     </div>\n    </div>\n    <div class=\"context\">`);\n\n    if (info.src) {\n       "
        " try {\n            var code = fs.readTextFile(info.src).replace(\'\\r\', \'\');\n     "
        "       code = hljs.highlightAuto(code).value;\n            var lines = code.split"
        "(\'\\n\');\n            htmls.push(`<pre><code class=\"lang-JavaScript\">`);\n         "
        "   lines.forEach((line, i) => {\n                var s = info.lines[i] > 0 ? \'\' :"
        " \'class=\"nocov\"\';\n                htmls.push(`<span class=\"no\">${i+1}</span><spa"
        "n class=\"no\">${info.lines[i]}</span><span ${s}>${line}</span>\\n`);\n            }"
        ");\n            htmls.push(`</code></pre>`);\n        } catch (e) {\n            ht"
        "mls.push(`File \"${info.src}\" not found.`);\n        }\n\n    } else {\n        htmls"
        ".push(`<table><tr><th width=\"99%\">Files</th><th colspan=2>Lines</th><th>Function"
        "s</th></tr>`);\n\n        Object.keys(info.subs).sort().forEach(k => {\n           "
        " htmls.push(`<tr><td><a href=\"${info.subs[k].pname}\">${k}</a></td>${gen_bar(info"
        ".subs[k].stats.line_cov, info.subs[k].stats.line_cnt)}\n            ${gen_info_td"
        "(info.subs[k].stats.line_cov, info.subs[k].stats.line_cnt)}\n            ${gen_in"
        "fo_td(info.subs[k].stats.func_cov, info.subs[k].stats.func_cnt)}\n            </t"
        "r>`);\n        });\n\n        htmls.push(`</table>`);\n    }\n\n    htmls.push(`</div>"
        "</body></html>`);\n\n    fs.writeFile(path.join(base_path, info.pname), htmls.join"
        "(\'\'));\n}\n\nfunction gen_html(base_path, info) {\n    var ks = Object.keys(info.sub"
        "s);\n    while (ks.length == 1) {\n        info = info.subs[ks[0]];\n        ks = O"
        "bject.keys(info.subs);\n    }\n\n    var _id = 0;\n    var files = [];\n\n    function"
        " count_stats(cur, path, name) {\n        var id = _id++;\n        var pname = id ="
        "== 0 ? \'index.html\' : `page_${id}.html`;\n\n        if (path !== \'\')\n            p"
        "ath += \' » \';\n        var path1 = path + `<a href=\"${pname}\">${name}</a>`;\n\n    "
        "    var ks = Object.keys(cur.subs);\n        var stats = cur.stats;\n        if (s"
        "tats == undefined) {\n            stats = {\n                line_cnt: 0,\n        "
        "        line_cov: 0,\n                func_cnt: 0,\n                func_cov: 0\n  "
        "          };\n\n            ks = ks.sort();\n            ks.forEach(k => {\n        "
        "        var stats1 = count_stats(cur.subs[k], path1, k);\n                stats.l"
        "ine_cnt += stats1.line_cnt;\n                stats.line_cov += stats1.line_cov;\n "
        "               stats.func_cnt += stats1.func_cnt;\n                stats.func_cov"
        " += stats1.func_cov;\n            });\n\n            cur.stats = stats;\n        }\n\n"
        "        cur.name = name;\n        cur.pname = pname;\n        cur.path = path + na"
        "me;\n\n        files[id] = cur;\n\n        return stats;\n    }\n\n    count_stats(info"
        ", \'\', \'All files\');\n\n    files.forEach(file => gen_one_html(base_path, file));\n}"
        "\n\nif (process.argv.length < 4)\n    console.log(\"\\nUsage: fibjs --cov-process lco"
        "v-file output\\n\");\nelse {\n    var i;\n    var base_path = path.fullpath(process.a"
        "rgv[3]);\n    var a = base_path.replace(/[\\\\\\/]+/g, \'/\').split(\'/\');\n\n    for (i "
        "= 1; i < a.length; i++)\n        try {\n            fs.mkdir(a.slice(0, i + 1).joi"
        "n(\'/\'));\n        } catch (e) {}\n\n    gen_html(base_path, read_lcov(process.argv["
        "2]));\n}",
    "--prof-process", "var fs = require(\'fs\');\nvar io = require(\'io\');\n\nfunction read_log(f) {\n    var "
        "bs = new io.BufferedStream(fs.openFile(f));\n    bs.EOL = \'\\n\';\n\n    var root = {"
        "\n        deep: 1,\n        level: 0,\n        cnt: 0,\n        js: 0,\n        subs:"
        " {}\n    };\n\n    var samp;\n    while ((samp = bs.readLine()) !== null) {\n        "
        "JSON.parse(samp).forEach(s => {\n            var sl = s.split(\'\\n\');\n            "
        "var js = sl[0].indexOf(\"(native code)\") === -1;\n\n            var level = 1;\n    "
        "        var cur = root;\n            cur.cnt++;\n            if (js)\n             "
        "   cur.js++;\n\n            sl.reverse().forEach(l => {\n                l = l.subs"
        "tr(7);\n                var sub = cur.subs[l];\n                if (sub === undefi"
        "ned)\n                    cur.subs[l] = sub = {\n                        level: 0,"
        "\n                        cnt: 0,\n                        js: 0,\n                "
        "        subs: {}\n                    };\n\n                sub.level = level++;\n\n "
        "               if (level > root.deep)\n                    root.deep = level;\n\n  "
        "              cur = sub;\n                cur.cnt++;\n                if (js)\n    "
        "                cur.js++;\n            });\n        });\n    }\n\n    return root;\n}\n"
        "\nfunction gen_svg(f, root) {\n    var sum = root.cnt;\n    var h = root.deep * 16 "
        "+ 66;\n    var svg_head = `<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PU"
        "BLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"
        "\">\n<svg version=\"1.1\" width=\"1000\" height=\"${h}\" onload=\"init(evt)\" viewBox=\"0 0"
        " 1000 ${h}\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/19"
        "99/xlink\">\n<defs >\n    <linearGradient id=\"background\" y1=\"0\" y2=\"1\" x1=\"0\" x2=\""
        "0\" >\n        <stop stop-color=\"#eeeeee\" offset=\"5%\" />\n        <stop stop-color="
        "\"#eeeeb0\" offset=\"95%\" />\n    </linearGradient>\n</defs>\n<style type=\"text/css\">\n"
        "    .func_g:hover {\n        stroke:black;\n        stroke-width:0.5;\n        curs"
        "or:pointer;\n    }\n</style>\n\n<script type=\"text/ecmascript\">\n<![CDATA[\n    var de"
        "tails, searchbtn, matchedtxt, svg;\n    function init(evt) { \n        details = d"
        "ocument.getElementById(\"details\").firstChild; \n        searchbtn = document.getE"
        "lementById(\"search\");\n        matchedtxt = document.getElementById(\"matched\");\n "
        "       svg = document.getElementsByTagName(\"svg\")[0];\n        searching = 0;\n   "
        "     unzoom();\n    }\n\n    // mouse-over for info\n    function s(node) {		// show"
        "\n        info = g_to_text(node);\n        details.nodeValue = \"Function: \" + info"
        ";\n    }\n    function c() {			// clear\n        details.nodeValue = \' \';\n    }\n\n  "
        "  // ctrl-F for search\n    window.addEventListener(\"keydown\",function (e) {\n    "
        "    if (e.keyCode === 114 || (e.ctrlKey && e.keyCode === 70)) {\n            e.pr"
        "eventDefault();\n            search_prompt();\n        }\n    })\n\n    // functions\n"
        "    function find_child(parent, name, attr) {\n        var children = parent.chil"
        "dNodes;\n        for (var i=0; i<children.length;i++) {\n            if (children["
        "i].tagName == name)\n                return (attr != undefined) ? children[i].att"
        "ributes[attr].value : children[i];\n        }\n        return;\n    }\n    function "
        "orig_save(e, attr, val) {\n        if (e.attributes[\"_orig_\"+attr] != undefined) "
        "return;\n        if (e.attributes[attr] == undefined) return;\n        if (val == "
        "undefined) val = e.attributes[attr].value;\n        e.setAttribute(\"_orig_\"+attr,"
        " val);\n    }\n    function orig_load(e, attr) {\n        if (e.attributes[\"_orig_\""
        "+attr] == undefined) return;\n        e.attributes[attr].value = e.attributes[\"_o"
        "rig_\"+attr].value;\n        e.removeAttribute(\"_orig_\"+attr);\n    }\n    function "
        "g_to_text(e) {\n        var text = find_child(e, \"title\").firstChild.nodeValue;\n "
        "       return (text)\n    }\n    function g_to_func(e) {\n        var func = g_to_t"
        "ext(e);\n        if (func != null)\n            func = func.replace(/ .*/, \"\");\n  "
        "      return (func);\n    }\n    function update_text(e) {\n        var r = find_ch"
        "ild(e, \"rect\");\n        var t = find_child(e, \"text\");\n        var w = parseFloa"
        "t(r.attributes[\"width\"].value) -3;\n        var txt = find_child(e, \"title\").text"
        "Content.replace(/\\\\([^(]*\\\\)$/,\"\");\n        t.attributes[\"x\"].value = parseFloat"
        "(r.attributes[\"x\"].value) +3;\n        \n        // Smaller than this size won\'t f"
        "it anything\n        if (w < 2*12*0.59) {\n            t.textContent = \"\";\n       "
        "     return;\n        }\n        \n        t.textContent = txt;\n        // Fit in f"
        "ull text width\n        if (/^ *$/.test(txt) || t.getSubStringLength(0, txt.lengt"
        "h) < w)\n            return;\n        \n        for (var x=txt.length-2; x>0; x--) "
        "{\n            if (t.getSubStringLength(0, x+2) <= w) { \n                t.textCo"
        "ntent = txt.substring(0,x) + \"..\";\n                return;\n            }\n       "
        " }\n        t.textContent = \"\";\n    }\n\n    // zoom\n    function zoom_reset(e) {\n "
        "       if (e.attributes != undefined) {\n            orig_load(e, \"x\");\n         "
        "   orig_load(e, \"width\");\n        }\n        if (e.childNodes == undefined) retur"
        "n;\n        for(var i=0, c=e.childNodes; i<c.length; i++) {\n            zoom_rese"
        "t(c[i]);\n        }\n    }\n    function zoom_child(e, x, ratio) {\n        if (e.at"
        "tributes != undefined) {\n            if (e.attributes[\"x\"] != undefined) {\n     "
        "           orig_save(e, \"x\");\n                e.attributes[\"x\"].value = (parseFl"
        "oat(e.attributes[\"x\"].value) - x - 10) * ratio + 10;\n                if(e.tagNam"
        "e == \"text\") e.attributes[\"x\"].value = find_child(e.parentNode, \"rect\", \"x\") + 3"
        ";\n            }\n            if (e.attributes[\"width\"] != undefined) {\n          "
        "      orig_save(e, \"width\");\n                e.attributes[\"width\"].value = parse"
        "Float(e.attributes[\"width\"].value) * ratio;\n            }\n        }\n        \n   "
        "     if (e.childNodes == undefined) return;\n        for(var i=0, c=e.childNodes;"
        " i<c.length; i++) {\n            zoom_child(c[i], x-10, ratio);\n        }\n    }\n "
        "   function zoom_parent(e) {\n        if (e.attributes) {\n            if (e.attri"
        "butes[\"x\"] != undefined) {\n                orig_save(e, \"x\");\n                e."
        "attributes[\"x\"].value = 10;\n            }\n            if (e.attributes[\"width\"] "
        "!= undefined) {\n                orig_save(e, \"width\");\n                e.attribu"
        "tes[\"width\"].value = parseInt(svg.width.baseVal.value) - (10*2);\n            }\n "
        "       }\n        if (e.childNodes == undefined) return;\n        for(var i=0, c=e"
        ".childNodes; i<c.length; i++) {\n            zoom_parent(c[i]);\n        }\n    }\n "
        "   function zoom(node) { \n        var attr = find_child(node, \"rect\").attributes"
        ";\n        var width = parseFloat(attr[\"width\"].value);\n        var xmin = parseF"
        "loat(attr[\"x\"].value);\n        var xmax = parseFloat(xmin + width);\n        var "
        "ymin = parseFloat(attr[\"y\"].value);\n        var ratio = (svg.width.baseVal.value"
        " - 2*10) / width;\n        \n        // XXX: Workaround for JavaScript float issue"
        "s (fix me)\n        var fudge = 0.0001;\n        \n        var unzoombtn = document"
        ".getElementById(\"unzoom\");\n        unzoombtn.style[\"opacity\"] = \"1.0\";\n        \n"
        "        var el = document.getElementsByTagName(\"g\");\n        for(var i=0;i<el.le"
        "ngth;i++){\n            var e = el[i];\n            var a = find_child(e, \"rect\")."
        "attributes;\n            var ex = parseFloat(a[\"x\"].value);\n            var ew = "
        "parseFloat(a[\"width\"].value);\n            // Is it an ancestor\n            if (0"
        " == 0) {\n                var upstack = parseFloat(a[\"y\"].value) > ymin;\n        "
        "    } else {\n                var upstack = parseFloat(a[\"y\"].value) < ymin;\n    "
        "        }\n            if (upstack) {\n                // Direct ancestor\n        "
        "        if (ex <= xmin && (ex+ew+fudge) >= xmax) {\n                    e.style[\""
        "opacity\"] = \"0.5\";\n                    zoom_parent(e);\n                    e.onc"
        "lick = function(e){unzoom(); zoom(this);};\n                    update_text(e);\n "
        "               }\n                // not in current path\n                else\n   "
        "                 e.style[\"display\"] = \"none\";\n            }\n            // Child"
        "ren maybe\n            else {\n                // no common path\n                i"
        "f (ex < xmin || ex + fudge >= xmax) {\n                    e.style[\"display\"] = \""
        "none\";\n                }\n                else {\n                    zoom_child(e"
        ", xmin, ratio);\n                    e.onclick = function(e){zoom(this);};\n      "
        "              update_text(e);\n                }\n            }\n        }\n    }\n  "
        "  function unzoom() {\n        var unzoombtn = document.getElementById(\"unzoom\");"
        "\n        unzoombtn.style[\"opacity\"] = \"0.0\";\n        \n        var el = document."
        "getElementsByTagName(\"g\");\n        for(i=0;i<el.length;i++) {\n            el[i]."
        "style[\"display\"] = \"block\";\n            el[i].style[\"opacity\"] = \"1\";\n          "
        "  zoom_reset(el[i]);\n            update_text(el[i]);\n        }\n    }	\n\n    // se"
        "arch\n    function reset_search() {\n        var el = document.getElementsByTagNam"
        "e(\"rect\");\n        for (var i=0; i < el.length; i++) {\n            orig_load(el["
        "i], \"fill\")\n        }\n    }\n    function search_prompt() {\n        if (!searchin"
        "g) {\n            var term = prompt(\"Enter a search term (regexp \" +\n            "
        "    \"allowed, eg: ^ext4_)\", \"\");\n            if (term != null) {\n               "
        " search(term)\n            }\n        } else {\n            reset_search();\n       "
        "     searching = 0;\n            searchbtn.style[\"opacity\"] = \"0.1\";\n            "
        "searchbtn.firstChild.nodeValue = \"Search\"\n            matchedtxt.style[\"opacity\""
        "] = \"0.0\";\n            matchedtxt.firstChild.nodeValue = \"\"\n        }\n    }\n    "
        "function search(term) {\n        var re = new RegExp(term);\n        var el = docu"
        "ment.getElementsByTagName(\"g\");\n        var matches = new Object();\n        var "
        "maxwidth = 0;\n        for (var i = 0; i < el.length; i++) {\n            var e = "
        "el[i];\n            if (e.attributes[\"class\"].value != \"func_g\")\n                "
        "continue;\n            var func = g_to_func(e);\n            var rect = find_child"
        "(e, \"rect\");\n            if (rect == null) {\n                // the rect might b"
        "e wrapped in an anchor\n                // if nameattr href is being used\n       "
        "         if (rect = find_child(e, \"a\")) {\n                    rect = find_child("
        "r, \"rect\");\n                }\n            }\n            if (func == null || rect"
        " == null)\n                continue;\n\n            // Save max width. Only works a"
        "s we have a root frame\n            var w = parseFloat(rect.attributes[\"width\"].v"
        "alue);\n            if (w > maxwidth)\n                maxwidth = w;\n\n            "
        "if (func.match(re)) {\n                // highlight\n                var x = parse"
        "Float(rect.attributes[\"x\"].value);\n                orig_save(rect, \"fill\");\n    "
        "            rect.attributes[\"fill\"].value =\n                    \"rgb(230,0,230)\""
        ";\n\n                // remember matches\n                if (matches[x] == undefin"
        "ed) {\n                    matches[x] = w;\n                } else {\n             "
        "       if (w > matches[x]) {\n                        // overwrite with parent\n  "
        "                      matches[x] = w;\n                    }\n                }\n  "
        "              searching = 1;\n            }\n        }\n        if (!searching)\n   "
        "         return;\n\n        searchbtn.style[\"opacity\"] = \"1.0\";\n        searchbtn."
        "firstChild.nodeValue = \"Reset Search\"\n\n        // calculate percent matched, exc"
        "luding vertical overlap\n        var count = 0;\n        var lastx = -1;\n        v"
        "ar lastw = 0;\n        var keys = Array();\n        for (k in matches) {\n         "
        "   if (matches.hasOwnProperty(k))\n                keys.push(k);\n        }\n      "
        "  // sort the matched frames by their x location\n        // ascending, then widt"
        "h descending\n        keys.sort(function(a, b){\n                return a - b;\n   "
        "         if (a < b || a > b)\n                return a - b;\n            return ma"
        "tches[b] - matches[a];\n        });\n        // Step through frames saving only th"
        "e biggest bottom-up frames\n        // thanks to the sort order. This relies on t"
        "he tree property\n        // where children are always smaller than their parents"
        ".\n        for (var k in keys) {\n            var x = parseFloat(keys[k]);\n       "
        "     var w = matches[keys[k]];\n            if (x >= lastx + lastw) {\n           "
        "     count += w;\n                lastx = x;\n                lastw = w;\n         "
        "   }\n        }\n        // display matched percent\n        matchedtxt.style[\"opac"
        "ity\"] = \"1.0\";\n        pct = 100 * count / maxwidth;\n        if (pct == 100)\n   "
        "         pct = \"100\"\n        else\n            pct = pct.toFixed(1)\n        match"
        "edtxt.firstChild.nodeValue = \"Matched: \" + pct + \"%\";\n    }\n    function searcho"
        "ver(e) {\n        searchbtn.style[\"opacity\"] = \"1.0\";\n    }\n    function searchou"
        "t(e) {\n        if (searching) {\n            searchbtn.style[\"opacity\"] = \"1.0\";\n"
        "        } else {\n            searchbtn.style[\"opacity\"] = \"0.1\";\n        }\n    }"
        "\n]]>\n</script>\n\n<rect x=\"0.0\" y=\"0\" width=\"1000.0\" height=\"${h}.0\" fill=\"url(#ba"
        "ckground)\"  />\n<text text-anchor=\"middle\" x=\"500\" y=\"24\" font-size=\"17\" font-fam"
        "ily=\"Verdana\" fill=\"rgb(0,0,0)\"  >Flame Graph</text>\n<text text-anchor=\"\" x=\"10."
        "00\" y=\"24\" font-size=\"12\" font-family=\"Verdana\" fill=\"rgb(0,0,0)\" id=\"unzoom\" on"
        "click=\"unzoom()\" style=\"opacity:0.0;cursor:pointer\" >Reset Zoom</text>\n<text tex"
        "t-anchor=\"\" x=\"890.00\" y=\"24\" font-size=\"12\" font-family=\"Verdana\" fill=\"rgb(0,0"
        ",0)\" id=\"search\" onmouseover=\"searchover()\" onmouseout=\"searchout()\" onclick=\"se"
        "arch_prompt()\" style=\"opacity:0.1;cursor:pointer\" >Search</text>\n<text text-anch"
        "or=\"\" x=\"1090.00\" y=\"${h*2-3}\" font-size=\"12\" font-family=\"Verdana\" fill=\"rgb(0,"
        "0,0)\" id=\"matched\" > </text>\n<text text-anchor=\"\" x=\"10\" y=\"${h-17}\" font-size=\""
        "12\" font-family=\"Verdana\" fill=\"rgb(0,0,0)\" id=\"details\" > </text>\n`;\n    var sv"
        "g_foot = `</svg>`;\n\n    var f = fs.openFile(f, \"w\");\n    f.write(svg_head);\n\n   "
        " function hot() {\n        var r = Math.floor(Math.random() * 50) + 205;\n        "
        "var g = Math.floor(Math.random() * 230) + 0;\n        var b = Math.floor(Math.ran"
        "dom() * 55) + 0;\n        return `rgb(${r},${g},${b})`;\n    }\n\n    function cold("
        ") {\n        var r = Math.floor(Math.random() * 60) + 80;\n        var g = Math.fl"
        "oor(Math.random() * 60) + 80;\n        var b = Math.floor(Math.random() * 55) + 1"
        "90;\n        return `rgb(${r},${g},${b})`;\n    }\n\n    function gen_node(name, nod"
        "e, pos) {\n        var x = 10 + 981 * pos / sum;\n        var y = h - 49 - node.le"
        "vel * 16;\n\n        var rgb = node.js > 0 ? hot() : cold();\n\n        f.write(`<g "
        "class=\"func_g\" onmouseover=\"s(this)\" onmouseout=\"c()\" onclick=\"zoom(this)\">\n<tit"
        "le>${name} (${node.cnt} samples, ${(100*node.cnt/sum).toFixed(2)}%)</title><rect"
        " x=\"${x.toFixed(2)}\" y=\"${y}\" width=\"${(981*node.cnt/sum).toFixed(2)}\" height=\"1"
        "5.0\" fill=\"${rgb}\" rx=\"2\" ry=\"2\" />\n<text text-anchor=\"\" x=\"${(x+3).toFixed(2)}\""
        " y=\"${y+10.5}\" font-size=\"12\" font-family=\"Verdana\" fill=\"rgb(0,0,0)\"></text>\n</"
        "g>`);\n\n        for (var l in node.subs) {\n            var n = node.subs[l];\n    "
        "        if (n.cnt > 0) {\n                gen_node(l, n, pos);\n                po"
        "s += n.cnt;\n            }\n        }\n    }\n\n    gen_node(\"all\", root, 0);\n\n    f."
        "write(svg_foot);\n}\n\nif (process.argv.length < 4)\n    console.log(\"\\nUsage: fibjs"
        " --prof-process logfile outfile\\n\");\nelse\n    gen_svg(process.argv[3], read_log("
        "process.argv[2]));",
    NULL
};
}